### 1488.Longest-Sequence (longest arithmetic sequence from a set)

#### 解法1：

对于等差数列的题目,我们常用的方法是用末位两位元素来唯一确定一个数列.令DP[i][j]表示以元素i,j结尾的等差数列的长度,那么显然如果能找到一个索引k,使得A[i]\*2==A[k]+A[j]的话,就可以有DP[i][j]=DP[i][k]+1

那么如何查找到k呢?我们不需要用一个hash表根据A[k]的值来对应k.此题不要求固定元素在数组里的位置,可以提前排序.对于一个有序数列要查找等差数列,总会有更便利的条件.这里就用到了双指针的思想.

我们固定了i之后,就可以以i为中心,左右指针往两边推进,用o(n)时间找到所有A[left]+A[right]==A[i]\*2的组合,这样就可以一遍更新完所有的DP[i][right],避免了显示地遍历right.

#### 解法2：

有一种更优秀的解法，时间是o(N^2)，但除了set本身之外不占用额外空间。这种方法和用o(N)时间在一个集合中找最长的连续数组是一个思想（回忆一下？）。

我们在集合中任意找配对(i,j)，计算得到公差是d，如果i-d不在set中，就说明(i,j)是某个全新的等差数列的前两个元素，我们以他们为开头，通过公差d不断地往后探索，计算这个数列的长度。如果i-d已经出现在了set中，说明(i,j)是某个等差数列中段的元素，我们放弃对这个数列的探索，因为我们约定只从数列的开头两个才开始往后探索。

请仔细体会，上述的算法时间复杂度是o(N^2)。这和dfs找connected island是一个道理。
