### 1365.Minimum-Cycle-Section

此题比较难,有KMP算法的思想.

我们设置一个数组prev[i],记录的是i之前最近一个与array[i]数值相同的位置.当然,这个说法并不准确,其实它记录的是疑似最近一个循环节内与array[i]数值相同的位置.我们来看是怎么实现的.

我们用两个指针j和i.指针j用来寻找指针i在之前循环节内的配对位置.
```cpp
while (i<N)
{
  if (j==0 && array[i]!=array[j]) // i配对不成功,且j已经无路可退,就标记i的配对是-1;放弃这个i,考虑下一轮的i++
  {
    array[i] = -1;
    i++;
  }
  else if (array[i]==array[j])   //记录成功的配对
  {
    prev[i] = j;
    i++;
    j++;
  }
  else        //配对不成功的话,我们回溯到上一个与array[j-1]数值相同的位置,再加一.
  {
    j--;
    j = prev[j];
    j++;
  }
}
```
最后的结果应该是查看N-1和它之前的配对位置prev[N-1],两者的差就是循环节的长度.
